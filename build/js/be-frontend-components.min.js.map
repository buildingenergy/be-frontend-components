{"version":3,"sources":["scrollAffix.js","tel.js","module.js","buildingMapCtrl.js","buildingMap.js"],"names":["angular","module","directive","restrict","scope","scrollAffixHeight","scrollAffixDebug","link","ele","w","element","window","on","sc","scrollTop","console","log","addClass","removeClass","$on","off","filter","tel","value","toString","trim","replace","match","country","city","number","length","slice","makePopupHTML","content","controller","$scope","geo","noop","config","getConfig","_","defaults","markerIconActive","markerIcon","onSiteClick","onSiteMouseOver","onSiteMouseOut","popupHTML","building","address_line_1","onViewportChange","onBuildingChange","loadAPI","_buildingWatches","_buildingIndices","_dynamicBuildings","sites","loadBuilding","index","id","assign","cache_building","loadSite","siteData","bid","building_snapshot_id","getSite","getBuilding","site","buildings","createMap","map","mapOptions","minZoom","tileset","L","addLayer","tileLayer","attribution","subdomains","maxZoom","mapbox","accessToken","error","mapboxId","defaultMarkerIcon","marker","icon","marker-size","marker-color","withDynamicBuilding","callback","promise","get_building_snapshot","canonical_building_id","then","data","cached","setupDynamicBuildingSiteInterop","refreshDynamicBuildings","i","sitePopupIsOpen","hasLayer","getPopup","setupStaticBuildingSiteInterop","setupBuildingWatches","_markerClick","e","target","updateBuildingHighlight","_applyBuildingChange","_markerMouseOver","_markerMouseOut","setupSite","latlng","lat","parseFloat","latitude","lng","longitude","siteLayer","setupPopup","popup","autoPan","minWidth","maxWidth","closeButton","setContent","bindPopup","openOnClick","_removeWatches","forEach","cb","debounce","$apply","_buildingChange","watch","$watch","push","updateBuildings","openPopup","closePopup","togglePopup","highlight","buildingHighlight","_map","setIcon","setZIndexOffset","_highlighted","updateAllBuildingsHighlight","pruneMarkers","currentMarkers","getLayers","removeLayer","newSites","getSites","newSiteMap","updateBuilding","centerOnMap","zoomToShowLayer","popupClassName","position","xClass","yClass","dim","getSize","x","y","setPopupClass","latLngToContainerPoint","getLatLng","$","_container","initialCenter","initialZoom","setMapBounds","layer","bounds","getBounds","fitBounds","padding","setView","MarkerClusterGroup","spiderfyDistanceMultiplier","maxClusterRadius","zoom","controlLayer","control","layers","Buildings","addTo","initialize","find","one","popupIsOpen","_leaflet_id","cluster","updateClusterHighlight","getZoom","clusters","markers","m","__parent","uniq","c","_zoom","_icon"],"mappings":"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","file":"be-frontend-components.min.js","sourcesContent":["/**\n * :copyright: (c) 2015 Building Energy Inc\n * :license: see LICENSE for more details.\n */\n(function (angular) {\n\n  /**\n   * like bootstrap affix, adds class `fixie` to pin elements when the\n   * scroll-affix-height is met.\n   * Usage:\n   *  <div class=\"section_nav_container\" scroll-affix scroll-affix-height=\"110\">\n   *      <div class=\"section_nav\">\n   *          <a href=\"#building\" offset=\"45\" du-smooth-scroll du-scrollspy>Building</a>\n   *          <a href=\"#owner\" offset=\"45\" du-smooth-scroll du-scrollspy>Owner</a>\n   *          <a href=\"#audit\" offset=\"45\" du-smooth-scroll du-scrollspy>Audit</a>\n   *          <a href=\"#eems\" offset=\"45\" du-smooth-scroll du-scrollspy>EEMs</a>\n   *          <a href=\"#confirm\" offset=\"45\" du-smooth-scroll du-scrollspy>Confirm</a>\n   *          <a href=\"#comments\" offset=\"45\" du-smooth-scroll du-scrollspy><i class=\"fa fa-comments\"></i> Comments</a>\n   *      </div>\n   *  </div>\n   */\n  angular.module('scrollAffix', [])\n  .directive('scrollAffix', function () {\n    return {\n      restrict: 'A',\n      scope: {\n        scrollAffixHeight: '@?',\n        scrollAffixDebug: '@?'\n      },\n      link: function (scope, ele, attrs) {\n        var w = angular.element(window);\n        scope.scrollAffixHeight = scope.scrollAffixHeight || 147;\n        scope.scrollAffixHeight = +scope.scrollAffixHeight;\n\n        w.on('scroll', function (e) {\n          var sc;\n          sc = angular.element(window).scrollTop();\n          if (scope.scrollAffixDebug) {\n            console.log({scrollTop: sc});\n          }\n          if (sc > scope.scrollAffixHeight) {\n            ele.addClass('fixie');\n          } else {\n            ele.removeClass('fixie');\n          }\n        });\n\n        scope.$on('$destroy', function () {\n          w.off('scroll');\n        });\n      }\n    };\n  });\n\n})(window.angular);\n","// from http://stackoverflow.com/questions/12700145/how-to-format-a-telephone-number-in-angularjs\n/**\n * telephone filter:\n * usage:\n *  HTML: {{ phoneNumber | tel }}\n *  JS:\n *      phoneNumber = 6142225555\n *      $filter('tel')(phoneNumber) // outputs \"(614) 222-5555\"\n */\nangular.module('tel', []).filter('tel', function () {\n    return function (tel) {\n        if (!tel) { return ''; }\n\n        var value = tel.toString().trim().replace(/^\\+/, '');\n\n        if (value.match(/[^0-9]/)) {\n            return tel;\n        }\n\n        var country, city, number;\n\n        switch (value.length) {\n            case 10: // +1PPP####### -> C (PPP) ###-####\n                country = 1;\n                city = value.slice(0, 3);\n                number = value.slice(3);\n                break;\n\n            case 11: // +CPPP####### -> CCC (PP) ###-####\n                country = value[0];\n                city = value.slice(1, 4);\n                number = value.slice(4);\n                break;\n\n            case 12: // +CCCPP####### -> CCC (PP) ###-####\n                country = value.slice(0, 3);\n                city = value.slice(3, 5);\n                number = value.slice(5);\n                break;\n\n            default:\n                return tel;\n        }\n\n        if (country === 1) {\n            country = \"\";\n        }\n\n        number = number.slice(0, 3) + '-' + number.slice(3);\n\n        return (country + \" (\" + city + \") \" + number).trim();\n    };\n});\n","(function(angular) {\n    angular.module('BE.frontend.buildingMap', []);\n})(angular);","/*jshint multistr: true */\n\n(function(angular) {\n\n    var makePopupHTML = function(content) {\n        return (' \\\n        <div class=\"map_pop_up_container bottom center\"> \\\n          <div class=\"arrow\"></div> \\\n          <div class=\"map_pop_up_inner\"> \\\n              ' + content + ' \\\n          </div> \\\n        </div>');\n    };\n\n    angular.module('BE.frontend.buildingMap')\n        .controller('BuildingMapController', [\n            '$scope',\n            'geo_service',\n            function($scope, geo) {\n\n                var noop = function() {};\n                $scope.config = $scope.getConfig() || {};\n                var config = $scope.config = _.defaults($scope.config, {\n                    markerIconActive: $scope.config.markerIcon,\n                    onSiteClick: function(building) {},\n                    onSiteMouseOver: function(building) {},\n                    onSiteMouseOut: function(building) {},\n                    popupHTML: function(building) {\n                        return \"\" + building.address_line_1;\n                    },\n                    onViewportChange: noop,\n                    onBuildingChange: noop,\n                    loadAPI: {},\n                });\n\n                var _buildingWatches = [];\n                var _buildingIndices = {};\n                var _dynamicBuildings = {};  // mainly used to check if a building has been dynamically loaded yet\n                $scope.sites = {};\n\n                var loadBuilding = function(index, building) {\n                    _buildingIndices[building.id] = index;\n                    _.assign(_dynamicBuildings[building.id], building);\n                    geo.cache_building(building);\n                };\n\n                var loadSite = function(siteData) {\n                    var bid = siteData.building_snapshot_id;\n                    if(!$scope.sites[bid]) {\n                        $scope.sites[bid] = siteData;\n                    }\n                    return $scope.sites[bid];\n                };\n\n                /**\n                 * get site corresponding to a building\n                 * @param  {building} building\n                 * @return {site or null}\n                 */\n                $scope.getSite = function(building) {\n                    return $scope.sites[building.id];\n                };\n\n                /**\n                 * get the building corresponding to a site\n                 * @param  {site} site\n                 * @return {building or null}\n                 */\n                $scope.getBuilding = function(site) {\n                    return $scope.buildings[_buildingIndices[site.building_snapshot_id]];\n                };\n\n\n                $scope.createMap = function(element) {\n                    var map;\n                    var mapOptions = {\n                        minZoom: 3,\n                    };\n\n                    if ($scope.tileset == 'mapquest-osm') {\n                        map = L.map(element, mapOptions);\n                        map.addLayer(\n                            L.tileLayer('http://otile{s}.mqcdn.com/tiles/1.0.0/map/{z}/{x}/{y}.jpeg', {\n                                attribution: 'Tiles by <a href=\"http://www.mapquest.com/\">MapQuest</a> &mdash; Map data &copy; <a href=\"http://openstreetmap.org\">OpenStreetMap</a> contributors, <a href=\"http://creativecommons.org/licenses/by-sa/2.0/\">CC-BY-SA</a>',\n                                subdomains: '1234',\n                                maxZoom: 18,  // Leaflet default\n                            })\n                        );\n                    } else if ($scope.tileset == 'mapbox') {\n                        if (!L.mapbox) {\n                            console.error(\"No mapbox.js found!\");\n                        } else if (!L.mapbox.accessToken) {\n                            console.error(\"Must supply L.mapbox.accessToken\");\n                        }\n                        map = L.mapbox.map(element, $scope.mapboxId);\n                        defaultMarkerIcon = L.mapbox.marker.icon({\n                            'marker-size': 'small',\n                            'marker-color': '#AA60D6',\n                        });\n                    } else {\n                        console.error(\"Unknown map tileset: \" + $scope.tileset);\n                    }\n\n                    return map;\n                };\n\n                /**\n                 * Very important function to asynchronously fetch and load building info\n                 * for a site, then do stuff. It's safe to call it a lot, since\n                 * all loaded buildings are cached, letting the promise resolve\n                 * immediately.\n                 *\n                 * @param  {site}   the site for which to fetch the building\n                 * @param  {Function} callback  a callback which takes the \\\n                 *                              newly fetched building and \\\n                 *                              a cached argument, specifying \\\n                 *                              whether the building was already \\\n                 *                              loaded or not\n                 */\n                $scope.withDynamicBuilding = function(site, callback) {\n                    var building = $scope.getBuilding(site);\n                    if (building) {\n                        callback(building, true);\n                    } else {\n                        var promise = geo.get_building_snapshot(site.canonical_building_id);\n                        // console.log(_dynamicBuildings, site);\n                        promise.then(function(data) {\n                            // we don't actually care about data.cached since we're checking caching ourselves\n                            var cached = data.cached;\n                            if (! _dynamicBuildings[site.building_snapshot_id]) {\n                                _dynamicBuildings[site.building_snapshot_id] = data.building;\n                                setupDynamicBuildingSiteInterop(data.building, site);\n                            } else {\n                                cached = true;\n                            }\n                            callback(_dynamicBuildings[site.building_snapshot_id], cached);\n                        });\n                    }\n                };\n\n                var refreshDynamicBuildings = function() {\n                    for (var i in $scope.buildings) {\n                        var building = $scope.buildings[i];\n                        if (_dynamicBuildings[building.id]) {\n                            $scope.buildings[i] = _dynamicBuildings[building.id];\n                        }\n                    }\n                };\n\n                $scope.sitePopupIsOpen = function(site) {\n                    return $scope.map.hasLayer(site.marker.getPopup());\n                };\n\n                /**\n                 * Stuff that needs to happen after all buildings and sites\n                 * are initially loaded\n                 */\n                var setupStaticBuildingSiteInterop = function() {\n                    setupBuildingWatches();\n                };\n\n                /**\n                 * Stuff that needs to happen when a building is first dynamically\n                 * loaded wrt. a site (e.g. when a site is clicked for a building\n                 * that doesn't show in the table)\n                 */\n                var setupDynamicBuildingSiteInterop = function(building, site) {\n                    // currently nothing special needs to happen...\n                };\n\n                var _markerClick = function(e) {\n                    var site = e.target.site;\n                    $scope.withDynamicBuilding(site, function(building) {\n                        config.onSiteClick(building, site);\n                        $scope.updateBuildingHighlight(building);\n                        _applyBuildingChange(building, site);\n                    });\n                };\n\n                var _markerMouseOver = function(e) {\n                    var site = e.target.site;\n                    $scope.withDynamicBuilding(site, function(building) {\n                        config.onSiteMouseOver(building, site);\n                        $scope.updateBuildingHighlight(building);\n                        _applyBuildingChange(building, site);\n                    });\n                };\n\n                var _markerMouseOut = function(e) {\n                    var site = e.target.site;\n                    $scope.withDynamicBuilding(site, function(building) {\n                        config.onSiteMouseOut(building, site);\n                        $scope.updateBuildingHighlight(building);\n                        _applyBuildingChange(building, site);\n                    });\n                };\n\n                /**\n                 * Set various properties on the site object\n                 * after loading. Gets called often, and shouldn't\n                 * involve building data.\n                 *\n                 * @param  {site} site\n                 */\n                var setupSite = function(site) {\n\n                    site.latlng = {\n                        lat: parseFloat(site.latitude),\n                        lng: parseFloat(site.longitude),\n                    };\n                    if (! site.marker) {\n                        var marker = L.marker(site.latlng, {\n                            icon: config.markerIcon,\n                        });\n                        marker.site = site;\n                        site.marker = marker;\n                        site.marker.on('click', _markerClick);\n                        site.marker.on('mouseover', _markerMouseOver);\n                        site.marker.on('mouseout', _markerMouseOut);\n                    }\n\n                    if (! $scope.siteLayer.hasLayer(site.marker)) {\n                        $scope.siteLayer.addLayer(site.marker);\n                    }\n\n                    return site;\n                };\n\n                /**\n                 * set up all relationships between building and site\n                 * (if possible)\n                 * @param  {building} building\n                 * @param  {site} site\n                 * Open the created popup immediately\n                 */\n                var setupPopup = function(building, site) {\n                    var popup = L.popup({\n                        autoPan: false,\n                        minWidth: 400,\n                        maxWidth: 400,\n                        closeButton: false,\n                    }).setContent(\n                        makePopupHTML(config.popupHTML(building))\n                    );\n                    popup.site = site;\n                    popup.marker = site.marker; // this is apparently the only way to access the popup's marker\n                    site.marker.bindPopup(popup, {\n                        openOnClick: false,\n                    });\n                };\n\n                var _removeWatches = function() {\n                    _buildingWatches.forEach(\n                        function(cb) { cb(); }\n                    );\n                    _buildingWatches = [];\n                };\n\n                /**\n                 * Just wraps _buildingChange in an $apply\n                 */\n                var _applyBuildingChange = _.debounce(function (building) {\n                    $scope.$apply(function() { _buildingChange(building); });\n                }, 100);\n\n                /**\n                 * Gets called during angular watches and various other places,\n                 * helps keep sites and building state in sync\n                 */\n                var _buildingChange = function (building, site) {\n                    if (! site) {\n                        site = $scope.getSite(building);\n                    }\n                    config.onBuildingChange(building, site);\n                };\n\n                /**\n                 * Sets up watches for building changes and tear down old ones\n                 * must be invoked after sites are set up\n                 * watches are only set for buildings with sites associated,\n                 * which should be a small number due to pagination (< 100)\n                 */\n                var setupBuildingWatches = function() {\n                    _removeWatches();\n                    for (var index in $scope.buildings) {\n                        building = $scope.buildings[index];\n                        site = $scope.getSite(building);\n                        if(site) {\n                            var watch = $scope.$watch('buildings['+index+']', _buildingChange, true);\n                            _buildingWatches.push(watch);\n                        } // else, the building was not geocoded\n                    }\n                };\n\n                /**\n                 * Just watches the buildings object for changes\n                 * This catches the search_service building refresh, which\n                 * swaps out the entire object\n                 */\n                $scope.$watch('buildings', function() {\n                    $scope.updateBuildings();\n                });\n\n                /**\n                 * Open the marker's popup only after making sure the building\n                 * data is loaded\n                 */\n                var openPopup = function(site, callback) {\n                    $scope.withDynamicBuilding(site, function(building) {\n                        if(!site.marker.getPopup()) {\n                            setupPopup(building, site);\n                        }\n                        var popup = site.marker.openPopup();\n                        if ('function' === typeof(callback)) {\n                            callback(popup);\n                        }\n                    });\n                };\n\n                var closePopup = function() {\n                    $scope.map.closePopup();\n                };\n\n                /**\n                 * Custom toggle popup. You would think we could use\n                 * Leaflet.marker.togglePopup() but we CAN'T!\n                 */\n                var togglePopup = function(site) {\n                    if ($scope.sitePopupIsOpen(site)) closePopup();\n                    else openPopup(site);\n                };\n\n                /**\n                 * update building's highlight state based on\n                 * config.buildingHightlight callback\n                 * This should be very idempotent, it gets called a lot\n                 */\n\n                /**\n                 * update building's highlight state based on\n                 * config.buildingHightlight callback\n                 * This should be very idempotent, it gets called a lot\n                 * @param  {object} building The building to update\n                 */\n                $scope.updateBuildingHighlight = function(building) {\n                    site = $scope.getSite(building);\n                    var highlight = config.buildingHighlight(building, site);\n\n                    if (site && site.marker && site.marker._map) {\n                        if(highlight) {\n                            site.marker.setIcon(config.markerIconActive);\n                            site.marker.setZIndexOffset(250);\n                            site._highlighted = true;\n                        } else {\n                            site.marker.setIcon(config.markerIcon);\n                            site.marker.setZIndexOffset(0);\n                            site._highlighted = false;\n                        }\n                    }\n                };\n\n                $scope.updateAllBuildingsHighlight = function(building) {\n                    for (var i in $scope.buildings) {\n                        building = $scope.buildings[i];\n                        $scope.updateBuildingHighlight(building);\n                    }\n                };\n\n                $scope.pruneMarkers = function() {\n                    var currentMarkers = $scope.siteLayer.getLayers();\n                    for (var i in currentMarkers) {\n                        var marker = currentMarkers[i];\n                        if (!(marker.site)) {\n                            $scope.siteLayer.removeLayer(marker);\n                        }\n                    }\n                };\n\n                $scope.updateBuildings = function() {\n                    var i;\n                    var newSites = $scope.getSites();\n                    var newSiteMap = {};\n                    var building, site, siteData;\n\n                    refreshDynamicBuildings();\n\n                    for (i in newSites) {\n                        newSiteMap[newSites[i].building_snapshot_id] = newSites[i];\n                    }\n\n                    for (i in $scope.buildings) {\n                        building = $scope.buildings[i];\n                        loadBuilding(i, building);\n                    }\n\n                    for (i in newSites) {\n                        siteData = newSites[i];\n\n                        if(!siteData.latitude) {\n                            // if the site wasn't geocoded, don't even bother\n                            // TODO: in the future, the backend response shouldn't\n                            // even include non-geocoded sites\n                            continue;\n                        }\n\n                        // loadSite will return an existing site object.\n                        // This prevents sites from being destroyed and re-created\n                        // every time the map moves.\n                        site = loadSite(siteData);\n\n                        // setupSite needs to happen every time\n                        setupSite(site);\n                    }\n\n                    // remove markers that don't match the search query\n                    for (var bid in $scope.sites) {\n                        if (!newSiteMap[bid]) {\n                            $scope.siteLayer.removeLayer($scope.sites[bid].marker);\n                        }\n                    }\n\n                    for (i in $scope.buildings) {\n                        building = $scope.buildings[i];\n                        site = $scope.getSite(building);\n                        if(site) {\n                            setupDynamicBuildingSiteInterop(building, site);\n                        } // else, the building was not geocoded\n                    }\n\n                    setupStaticBuildingSiteInterop();\n                };\n\n                config.loadAPI({\n                    'openPopup': openPopup,\n                    'closePopup': closePopup,\n                    'togglePopup': togglePopup,\n                    'getBuilding': $scope.getBuilding, // TODO: remove\n                    'getSite': $scope.getSite,\n                    'sitePopupIsOpen': $scope.sitePopupIsOpen,\n                    'updateBuilding': _buildingChange,\n                    'updateBuildings': $scope.updateBuildings,\n                    'updateBuildingHighlight': $scope.updateBuildingHighlight,\n                    'updateAllBuildingsHighlight': $scope.updateAllBuildingsHighlight,\n                    'withDynamicBuilding': $scope.withDynamicBuilding,\n                    'centerOnMap': function(site, callback) {\n                        $scope.siteLayer.zoomToShowLayer(site.marker, callback);\n                    },\n                    'pruneMarkers': $scope.pruneMarkers\n                });\n\n            }\n        ]);\n})(angular);\n","/**\n * Building Map Directive\n *\n * Creates a Leaflet map that displays clustered dynamically updated buildings\n * with popups and all kinds of bells and whistles.\n *\n * A lot of the complexity of this code comes from the fact that we have to keep\n * two distinct lists up to date and interoperating - the building list, which\n * show up in the building table, and the \"mapBuilding\", or \"site\" list, which\n * represents light-weight building objects that are displayed on the map.\n * In general there are many more sites than buildings\n * (up to 10,000 sites, up to 100 buildings), but when showing more information\n * on a site (e.g. in a popup), the entire building object be present. If it\n * already exists in the table, that object is used, but if not it is loaded\n * asynchronously and the necessary objects and events are created and bound\n * at that point\n *\n * Some key functions to understanding this code: (2014-11-26 MDD)\n * loadAPI - a callback that lets the parent receive a handy API into map\n *      functionality\n * withDynamicBuilding - accepts a callback that guarantees the existence of a\n *      building, crucial for working with the many times a building must be\n *      loaded asynchronously. It's safe to call this many times, as buildings\n *      are cached as they're loaded.\n * updateBuildings - winds up being called every time a new search query is\n *      fired. Existing sites are not updated, their markers and popups are\n *      preserved\n *\n */\n\n(function(angular) {\n\n    /**\n     * Get class name based on relative map position\n     * @param  {L.Map} map\n     * @param  {L.Point} position The marker position\n     * @return {String}          The popup class name\n     */\n    var popupClassName = function(map, position) {\n        var dim = map.getSize();\n        var xClass, yClass;\n\n        if (position.x <= dim.x/3) {\n            xClass = 'left';\n        } else if (position.x <= dim.x*2/3) {\n            xClass = 'center';\n        } else {\n            xClass = 'right';\n        }\n\n        if (position.y <= dim.y/2) {\n            yClass = 'top';\n        } else {\n            yClass = 'bottom';\n        }\n        return xClass + ' ' + yClass;\n    };\n\n    /**\n     * Set popup class based on its position on the map\n     * @param {L.Map} map\n     * @param {L.Popup} popup\n     */\n    var setPopupClass = function(map, popup) {\n\n        var position = map.latLngToContainerPoint(popup.marker.getLatLng());\n        $(popup._container).removeClass('top bottom left right center').addClass(\n            popupClassName(map, position) + ' has_value'\n        );\n    };\n\n    angular.module('BE.frontend.buildingMap')\n        .directive('buildingMap', [\n            function() {\n                return {\n                    restrict: 'A',\n                    scope: {\n                        buildings: '=buildings',\n                        getSites: '&buildingSites',\n                        getConfig: '&config',\n                        tileset: '@',\n                        initialCenter: '&',\n                        initialZoom: '&',\n                    },\n                    controller: 'BuildingMapController',\n                    link: function($scope, element, attrs) {\n\n                        var config = $scope.config;\n\n                        var defaultMarkerIcon = null;\n                        var map = $scope.createMap(element[0]);\n\n                        var _activeSite = null;\n\n                        /**\n                         * Determine if this marker is independent, or absorbed\n                         * into a cluster\n                         * @param  {[type]}  marker\n                         * @return {Boolean}\n                         */\n                        var isIndependent = function(marker) {\n                            var parent = $scope.siteLayer.getVisibleParent(marker);\n                            return parent === null || parent === marker;\n                        };\n\n                        /**\n                         * Fit map bounds to markers displayed\n                         * @param  {L.Map} map\n                         * @param  {L.LayerGroup} layer\n                         */\n                        var setMapBounds = _.debounce( function(map, layer) {\n                            if(layer.getLayers().length > 0) {\n                                var bounds = layer.getBounds();\n                                map.fitBounds(bounds, {padding: [20, 20]});\n                            } else {\n                                map.setView([40, -95], 4);\n                            }\n                        }, 300);\n\n                        $scope.map = map;\n\n                        $scope.siteLayer = new L.MarkerClusterGroup({\n                            spiderfyDistanceMultiplier: 2,\n                            maxClusterRadius: function(zoom) {\n                                if (zoom <= 15) return 60;\n                                else if (zoom <= 16) return 20;\n                                else return 2;\n                            },\n                        });\n\n                        map.addLayer($scope.siteLayer);\n\n                        $scope.controlLayer = L.control.layers([], {\n                            'Buildings': $scope.siteLayer,\n                        }).addTo(map);\n\n\n                        /************************\n                        ** MAP EVENT LISTENERS **\n                        ************************/\n\n                        map.on('load', function(e) {\n                            setMapBounds(map, $scope.siteLayer);\n\n                            // debounce, and throw away the first invocation\n                            map.on('zoomend dragend resize', _.debounce(function(e) {\n                                // NOTE: DON'T use moveend,\n                                // because that fires when the map loads!\n                                config.onViewportChange(map);\n                            }, 100));\n                            if (config.initialize) {\n                                config.initialize(map, $scope.controlLayer);\n                            }\n                        });\n\n                        map.on('popupopen', function(e) {\n                            setPopupClass(map, e.popup);\n                            $(e.popup._container).find('.close_it').one('click', function(e) {\n                                map.closePopup();\n                            });\n                            e.popup.site.popupIsOpen = true;\n                        });\n\n                        map.on('popupclose', function(e) {\n                            e.popup.site.popupIsOpen = false;\n                        });\n\n                        if($scope.initialCenter() && $scope.initialZoom()) {\n                            map.setView($scope.initialCenter(), $scope.initialZoom());\n                        } else {\n                            setMapBounds(map, $scope.siteLayer);\n                        }\n\n                        var _markerHighlighted = function(marker) {\n                            return marker.site._highlighted;\n                        };\n\n                        var _leaflet_id = function(cluster) {\n                            return cluster._leaflet_id;\n                        };\n\n                        var updateClusterHighlight = function() {\n                            var zoom = $scope.map.getZoom();\n                            var clusters = [];\n                            var markers = $scope.siteLayer.getLayers();\n\n                            for (var m in markers) {\n                                var marker = markers[m];\n                                var site = marker.site;\n                                if (site._highlighted) {\n                                    clusters.push(marker.__parent);\n                                }\n                            }\n                            clusters = _.uniq(clusters, _leaflet_id);\n                            for (var c in clusters) {\n                                var cluster = clusters[c];\n                                while (cluster.__parent && cluster._zoom >= zoom) {\n                                    if (cluster._icon) {\n                                        $(cluster._icon).addClass('marker-cluster-highlighted');\n                                    }\n                                    cluster = cluster.__parent;\n                                }\n                            }\n\n                        };\n\n                        $scope.siteLayer.on('animationend', function(e) {\n                            updateClusterHighlight();\n                            $scope.updateAllBuildingsHighlight();\n                            //\n                            // if(!_activeSite || !isIndependent(_activeSite.marker)) {\n                            //     map.closePopup();\n                            // }\n                        });\n\n                    },\n                };\n        }]);\n})(angular);\n"],"sourceRoot":"/source/"}