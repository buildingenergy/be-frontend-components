{"version":3,"sources":["scrollAffix.js","tel.js","module.js","buildingMapCtrl.js","buildingMap.js"],"names":["angular","module","directive","restrict","scope","scrollAffixHeight","scrollAffixDebug","link","ele","w","element","window","on","sc","scrollTop","console","log","addClass","removeClass","$on","off","filter","tel","value","toString","trim","replace","match","country","city","number","length","slice","makePopupHTML","content","controller","$scope","geo","noop","config","getConfig","_","defaults","markerIconActive","markerIcon","onSiteClick","onSiteMouseOver","onSiteMouseOut","popupHTML","building","address_line_1","onViewportChange","onBuildingChange","loadAPI","_buildingWatches","_buildingIndices","_dynamicBuildings","sites","loadBuilding","index","id","assign","cache_building","loadSite","siteData","bid","building_snapshot_id","getSite","getBuilding","site","buildings","createMap","map","tempOptions","mapOptions","minZoom","zoom","tileset","copy","MQ","mapLayer","error","layers","L","mapbox","accessToken","mapboxId","defaultMarkerIcon","marker","icon","marker-size","marker-color","withDynamicBuilding","callback","promise","get_building_snapshot","canonical_building_id","then","data","cached","setupDynamicBuildingSiteInterop","refreshDynamicBuildings","i","sitePopupIsOpen","hasLayer","getPopup","setupStaticBuildingSiteInterop","setupBuildingWatches","_markerClick","e","target","updateBuildingHighlight","_applyBuildingChange","_markerMouseOver","_markerMouseOut","setupSite","latlng","lat","parseFloat","latitude","lng","longitude","siteLayer","addLayer","setupPopup","popup","autoPan","minWidth","maxWidth","closeButton","setContent","bindPopup","openOnClick","_removeWatches","forEach","cb","debounce","$apply","_buildingChange","watch","$watch","push","updateBuildings","openPopup","closePopup","togglePopup","highlight","buildingHighlight","_map","setIcon","setZIndexOffset","_highlighted","updateAllBuildingsHighlight","pruneMarkers","currentMarkers","getLayers","removeLayer","newSites","getSites","newSiteMap","updateBuilding","centerOnMap","zoomToShowLayer","popupClassName","position","xClass","yClass","dim","getSize","x","y","setPopupClass","latLngToContainerPoint","getLatLng","$","_container","initialCenter","initialZoom","setMapBounds","layer","bounds","getBounds","fitBounds","padding","setView","MarkerClusterGroup","spiderfyDistanceMultiplier","maxClusterRadius","controlLayer","control","Buildings","addTo","initialize","find","one","popupIsOpen","_leaflet_id","cluster","updateClusterHighlight","getZoom","clusters","markers","m","__parent","uniq","c","_zoom","_icon"],"mappings":"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","file":"be-frontend-components.min.js","sourcesContent":["/**\n * :copyright: (c) 2015 Building Energy Inc\n * :license: see LICENSE for more details.\n */\n(function (angular) {\n\n  /**\n   * like bootstrap affix, adds class `fixie` to pin elements when the\n   * scroll-affix-height is met.\n   * Usage:\n   *  <div class=\"section_nav_container\" scroll-affix scroll-affix-height=\"110\">\n   *      <div class=\"section_nav\">\n   *          <a href=\"#building\" offset=\"45\" du-smooth-scroll du-scrollspy>Building</a>\n   *          <a href=\"#owner\" offset=\"45\" du-smooth-scroll du-scrollspy>Owner</a>\n   *          <a href=\"#audit\" offset=\"45\" du-smooth-scroll du-scrollspy>Audit</a>\n   *          <a href=\"#eems\" offset=\"45\" du-smooth-scroll du-scrollspy>EEMs</a>\n   *          <a href=\"#confirm\" offset=\"45\" du-smooth-scroll du-scrollspy>Confirm</a>\n   *          <a href=\"#comments\" offset=\"45\" du-smooth-scroll du-scrollspy><i class=\"fa fa-comments\"></i> Comments</a>\n   *      </div>\n   *  </div>\n   */\n  angular.module('scrollAffix', [])\n  .directive('scrollAffix', function () {\n    return {\n      restrict: 'A',\n      scope: {\n        scrollAffixHeight: '@?',\n        scrollAffixDebug: '@?'\n      },\n      link: function (scope, ele, attrs) {\n        var w = angular.element(window);\n        scope.scrollAffixHeight = scope.scrollAffixHeight || 147;\n        scope.scrollAffixHeight = +scope.scrollAffixHeight;\n\n        w.on('scroll', function (e) {\n          var sc;\n          sc = angular.element(window).scrollTop();\n          if (scope.scrollAffixDebug) {\n            console.log({scrollTop: sc});\n          }\n          if (sc > scope.scrollAffixHeight) {\n            ele.addClass('fixie');\n          } else {\n            ele.removeClass('fixie');\n          }\n        });\n\n        scope.$on('$destroy', function () {\n          w.off('scroll');\n        });\n      }\n    };\n  });\n\n})(window.angular);\n","// from http://stackoverflow.com/questions/12700145/how-to-format-a-telephone-number-in-angularjs\n/**\n * telephone filter:\n * usage:\n *  HTML: {{ phoneNumber | tel }}\n *  JS:\n *      phoneNumber = 6142225555\n *      $filter('tel')(phoneNumber) // outputs \"(614) 222-5555\"\n */\nangular.module('tel', []).filter('tel', function () {\n    return function (tel) {\n        if (!tel) { return ''; }\n\n        var value = tel.toString().trim().replace(/^\\+/, '');\n\n        if (value.match(/[^0-9]/)) {\n            return tel;\n        }\n\n        var country, city, number;\n\n        switch (value.length) {\n            case 10: // +1PPP####### -> C (PPP) ###-####\n                country = 1;\n                city = value.slice(0, 3);\n                number = value.slice(3);\n                break;\n\n            case 11: // +CPPP####### -> CCC (PP) ###-####\n                country = value[0];\n                city = value.slice(1, 4);\n                number = value.slice(4);\n                break;\n\n            case 12: // +CCCPP####### -> CCC (PP) ###-####\n                country = value.slice(0, 3);\n                city = value.slice(3, 5);\n                number = value.slice(5);\n                break;\n\n            default:\n                return tel;\n        }\n\n        if (country === 1) {\n            country = \"\";\n        }\n\n        number = number.slice(0, 3) + '-' + number.slice(3);\n\n        return (country + \" (\" + city + \") \" + number).trim();\n    };\n});\n","(function(angular) {\n    angular.module('BE.frontend.buildingMap', []);\n})(angular);","/*jshint multistr: true */\n\n(function(angular) {\n\n    var makePopupHTML = function(content) {\n        return (' \\\n        <div class=\"map_pop_up_container bottom center\"> \\\n          <div class=\"arrow\"></div> \\\n          <div class=\"map_pop_up_inner\"> \\\n              ' + content + ' \\\n          </div> \\\n        </div>');\n    };\n\n    angular.module('BE.frontend.buildingMap')\n        .controller('BuildingMapController', [\n            '$scope',\n            'geo_service',\n            function($scope, geo) {\n\n                var noop = function() {};\n                $scope.config = $scope.getConfig() || {};\n                var config = $scope.config = _.defaults($scope.config, {\n                    markerIconActive: $scope.config.markerIcon,\n                    onSiteClick: function(building) {},\n                    onSiteMouseOver: function(building) {},\n                    onSiteMouseOut: function(building) {},\n                    popupHTML: function(building) {\n                        return \"\" + building.address_line_1;\n                    },\n                    onViewportChange: noop,\n                    onBuildingChange: noop,\n                    loadAPI: {},\n                });\n\n                var _buildingWatches = [];\n                var _buildingIndices = {};\n                var _dynamicBuildings = {};  // mainly used to check if a building has been dynamically loaded yet\n                $scope.sites = {};\n\n                var loadBuilding = function(index, building) {\n                    _buildingIndices[building.id] = index;\n                    _.assign(_dynamicBuildings[building.id], building);\n                    geo.cache_building(building);\n                };\n\n                var loadSite = function(siteData) {\n                    var bid = siteData.building_snapshot_id;\n                    if(!$scope.sites[bid]) {\n                        $scope.sites[bid] = siteData;\n                    }\n                    return $scope.sites[bid];\n                };\n\n                /**\n                 * get site corresponding to a building\n                 * @param  {building} building\n                 * @return {site or null}\n                 */\n                $scope.getSite = function(building) {\n                    return $scope.sites[building.id];\n                };\n\n                /**\n                 * get the building corresponding to a site\n                 * @param  {site} site\n                 * @return {building or null}\n                 */\n                $scope.getBuilding = function(site) {\n                    return $scope.buildings[_buildingIndices[site.building_snapshot_id]];\n                };\n\n\n                $scope.createMap = function(element) {\n                    var map;\n                    var mapOptions = {\n                        minZoom: 3,\n                        zoom: 12,\n                    };\n                    var tempOptions;\n\n                    if ($scope.tileset === 'mapquest-osm') {\n                        tempOptions = angular.copy(mapOptions);\n                        if (!MQ || !MQ.mapLayer) {\n                            console.error(\"MapQuest layer missing! Make sure the MapQuest Maps plugin for Leaflet with AppKey is present. https://developer.mapquest.com/documentation/leaflet-plugins/maps\");\n                        }\n                        tempOptions.layers = MQ.mapLayer();\n                        map = L.map(element, tempOptions);\n                        // 7/11/2016 AKL - I normally remove commented code, but Michael D. has a fork of leaflet and a\n                        // fork of a leaflet plugin being used for something, check his commit log for details. I\n                        // cloned the two repos to BE today for reference. Today, MapQuest stopped allowing tiles\n                        // without an AppKey, so I had to update this code to use MapQuest's Leaflet plugin, which I\n                        // couldn't get working with the commented code below.\n                        //\n                        // BEGIN COMMENTED CODE\n                        // map.addLayer(\n                        //     L.tileLayer('https://otile{s}-s.mqcdn.com/tiles/1.0.0/map/{z}/{x}/{y}.jpeg', {\n                        //         attribution: 'Tiles by <a href=\"http://www.mapquest.com/\">MapQuest</a> &mdash; Map data &copy; <a href=\"http://openstreetmap.org\">OpenStreetMap</a> contributors, <a href=\"http://creativecommons.org/licenses/by-sa/2.0/\">CC-BY-SA</a>',\n                        //         subdomains: '1234',\n                        //         maxZoom: 17,  // Leaflet default\n                        //     })\n                        // );\n                        // END COMMENTED CODE\n                    } else if ($scope.tileset == 'mapbox') {\n                        if (!L.mapbox) {\n                            console.error(\"No mapbox.js found!\");\n                        } else if (!L.mapbox.accessToken) {\n                            console.error(\"Must supply L.mapbox.accessToken\");\n                        }\n                        map = L.mapbox.map(element, $scope.mapboxId);\n                        defaultMarkerIcon = L.mapbox.marker.icon({\n                            'marker-size': 'small',\n                            'marker-color': '#AA60D6',\n                        });\n                    } else {\n                        console.error(\"Unknown map tileset: \" + $scope.tileset);\n                    }\n\n                    return map;\n                };\n\n                /**\n                 * Very important function to asynchronously fetch and load building info\n                 * for a site, then do stuff. It's safe to call it a lot, since\n                 * all loaded buildings are cached, letting the promise resolve\n                 * immediately.\n                 *\n                 * @param  {site}   the site for which to fetch the building\n                 * @param  {Function} callback  a callback which takes the \\\n                 *                              newly fetched building and \\\n                 *                              a cached argument, specifying \\\n                 *                              whether the building was already \\\n                 *                              loaded or not\n                 */\n                $scope.withDynamicBuilding = function(site, callback) {\n                    var building = $scope.getBuilding(site);\n                    if (building) {\n                        callback(building, true);\n                    } else {\n                        var promise = geo.get_building_snapshot(site.canonical_building_id);\n                        // console.log(_dynamicBuildings, site);\n                        promise.then(function(data) {\n                            // we don't actually care about data.cached since we're checking caching ourselves\n                            var cached = data.cached;\n                            if (! _dynamicBuildings[site.building_snapshot_id]) {\n                                _dynamicBuildings[site.building_snapshot_id] = data.building;\n                                setupDynamicBuildingSiteInterop(data.building, site);\n                            } else {\n                                cached = true;\n                            }\n                            callback(_dynamicBuildings[site.building_snapshot_id], cached);\n                        });\n                    }\n                };\n\n                var refreshDynamicBuildings = function() {\n                    for (var i in $scope.buildings) {\n                        var building = $scope.buildings[i];\n                        if (_dynamicBuildings[building.id]) {\n                            $scope.buildings[i] = _dynamicBuildings[building.id];\n                        }\n                    }\n                };\n\n                $scope.sitePopupIsOpen = function(site) {\n                    return $scope.map.hasLayer(site.marker.getPopup());\n                };\n\n                /**\n                 * Stuff that needs to happen after all buildings and sites\n                 * are initially loaded\n                 */\n                var setupStaticBuildingSiteInterop = function() {\n                    setupBuildingWatches();\n                };\n\n                /**\n                 * Stuff that needs to happen when a building is first dynamically\n                 * loaded wrt. a site (e.g. when a site is clicked for a building\n                 * that doesn't show in the table)\n                 */\n                var setupDynamicBuildingSiteInterop = function(building, site) {\n                    // currently nothing special needs to happen...\n                };\n\n                var _markerClick = function(e) {\n                    var site = e.target.site;\n                    $scope.withDynamicBuilding(site, function(building) {\n                        config.onSiteClick(building, site);\n                        $scope.updateBuildingHighlight(building);\n                        _applyBuildingChange(building, site);\n                    });\n                };\n\n                var _markerMouseOver = function(e) {\n                    var site = e.target.site;\n                    $scope.withDynamicBuilding(site, function(building) {\n                        config.onSiteMouseOver(building, site);\n                        $scope.updateBuildingHighlight(building);\n                        _applyBuildingChange(building, site);\n                    });\n                };\n\n                var _markerMouseOut = function(e) {\n                    var site = e.target.site;\n                    $scope.withDynamicBuilding(site, function(building) {\n                        config.onSiteMouseOut(building, site);\n                        $scope.updateBuildingHighlight(building);\n                        _applyBuildingChange(building, site);\n                    });\n                };\n\n                /**\n                 * Set various properties on the site object\n                 * after loading. Gets called often, and shouldn't\n                 * involve building data.\n                 *\n                 * @param  {site} site\n                 */\n                var setupSite = function(site) {\n\n                    site.latlng = {\n                        lat: parseFloat(site.latitude),\n                        lng: parseFloat(site.longitude),\n                    };\n                    if (! site.marker) {\n                        var marker = L.marker(site.latlng, {\n                            icon: config.markerIcon,\n                        });\n                        marker.site = site;\n                        site.marker = marker;\n                        site.marker.on('click', _markerClick);\n                        site.marker.on('mouseover', _markerMouseOver);\n                        site.marker.on('mouseout', _markerMouseOut);\n                    }\n\n                    if (! $scope.siteLayer.hasLayer(site.marker)) {\n                        $scope.siteLayer.addLayer(site.marker);\n                    }\n\n                    return site;\n                };\n\n                /**\n                 * set up all relationships between building and site\n                 * (if possible)\n                 * @param  {building} building\n                 * @param  {site} site\n                 * Open the created popup immediately\n                 */\n                var setupPopup = function(building, site) {\n                    var popup = L.popup({\n                        autoPan: false,\n                        minWidth: 400,\n                        maxWidth: 400,\n                        closeButton: false,\n                    }).setContent(\n                        makePopupHTML(config.popupHTML(building))\n                    );\n                    popup.site = site;\n                    popup.marker = site.marker; // this is apparently the only way to access the popup's marker\n                    site.marker.bindPopup(popup, {\n                        openOnClick: false,\n                    });\n                };\n\n                var _removeWatches = function() {\n                    _buildingWatches.forEach(\n                        function(cb) { cb(); }\n                    );\n                    _buildingWatches = [];\n                };\n\n                /**\n                 * Just wraps _buildingChange in an $apply\n                 */\n                var _applyBuildingChange = _.debounce(function (building) {\n                    $scope.$apply(function() { _buildingChange(building); });\n                }, 100);\n\n                /**\n                 * Gets called during angular watches and various other places,\n                 * helps keep sites and building state in sync\n                 */\n                var _buildingChange = function (building, site) {\n                    if (! site) {\n                        site = $scope.getSite(building);\n                    }\n                    config.onBuildingChange(building, site);\n                };\n\n                /**\n                 * Sets up watches for building changes and tear down old ones\n                 * must be invoked after sites are set up\n                 * watches are only set for buildings with sites associated,\n                 * which should be a small number due to pagination (< 100)\n                 */\n                var setupBuildingWatches = function() {\n                    _removeWatches();\n                    for (var index in $scope.buildings) {\n                        building = $scope.buildings[index];\n                        site = $scope.getSite(building);\n                        if(site) {\n                            var watch = $scope.$watch('buildings['+index+']', _buildingChange, true);\n                            _buildingWatches.push(watch);\n                        } // else, the building was not geocoded\n                    }\n                };\n\n                /**\n                 * Just watches the buildings object for changes\n                 * This catches the search_service building refresh, which\n                 * swaps out the entire object\n                 */\n                $scope.$watch('buildings', function() {\n                    $scope.updateBuildings();\n                });\n\n                /**\n                 * Open the marker's popup only after making sure the building\n                 * data is loaded\n                 */\n                var openPopup = function(site, callback) {\n                    $scope.withDynamicBuilding(site, function(building) {\n                        if(!site.marker.getPopup()) {\n                            setupPopup(building, site);\n                        }\n                        var popup = site.marker.openPopup();\n                        if ('function' === typeof(callback)) {\n                            callback(popup);\n                        }\n                    });\n                };\n\n                var closePopup = function() {\n                    $scope.map.closePopup();\n                };\n\n                /**\n                 * Custom toggle popup. You would think we could use\n                 * Leaflet.marker.togglePopup() but we CAN'T!\n                 */\n                var togglePopup = function(site) {\n                    if ($scope.sitePopupIsOpen(site)) closePopup();\n                    else openPopup(site);\n                };\n\n                /**\n                 * update building's highlight state based on\n                 * config.buildingHightlight callback\n                 * This should be very idempotent, it gets called a lot\n                 */\n\n                /**\n                 * update building's highlight state based on\n                 * config.buildingHightlight callback\n                 * This should be very idempotent, it gets called a lot\n                 * @param  {object} building The building to update\n                 */\n                $scope.updateBuildingHighlight = function(building) {\n                    site = $scope.getSite(building);\n                    var highlight = config.buildingHighlight(building, site);\n\n                    if (site && site.marker && site.marker._map) {\n                        if(highlight) {\n                            site.marker.setIcon(config.markerIconActive);\n                            site.marker.setZIndexOffset(250);\n                            site._highlighted = true;\n                        } else {\n                            site.marker.setIcon(config.markerIcon);\n                            site.marker.setZIndexOffset(0);\n                            site._highlighted = false;\n                        }\n                    }\n                };\n\n                $scope.updateAllBuildingsHighlight = function(building) {\n                    for (var i in $scope.buildings) {\n                        building = $scope.buildings[i];\n                        $scope.updateBuildingHighlight(building);\n                    }\n                };\n\n                $scope.pruneMarkers = function() {\n                    var currentMarkers = $scope.siteLayer.getLayers();\n                    for (var i in currentMarkers) {\n                        var marker = currentMarkers[i];\n                        if (!(marker.site)) {\n                            $scope.siteLayer.removeLayer(marker);\n                        }\n                    }\n                };\n\n                $scope.updateBuildings = function() {\n                    var i;\n                    var newSites = $scope.getSites();\n                    var newSiteMap = {};\n                    var building, site, siteData;\n\n                    refreshDynamicBuildings();\n\n                    for (i in newSites) {\n                        newSiteMap[newSites[i].building_snapshot_id] = newSites[i];\n                    }\n\n                    for (i in $scope.buildings) {\n                        building = $scope.buildings[i];\n                        loadBuilding(i, building);\n                    }\n\n                    for (i in newSites) {\n                        siteData = newSites[i];\n\n                        if(!siteData.latitude) {\n                            // if the site wasn't geocoded, don't even bother\n                            // TODO: in the future, the backend response shouldn't\n                            // even include non-geocoded sites\n                            continue;\n                        }\n\n                        // loadSite will return an existing site object.\n                        // This prevents sites from being destroyed and re-created\n                        // every time the map moves.\n                        site = loadSite(siteData);\n\n                        // setupSite needs to happen every time\n                        setupSite(site);\n                    }\n\n                    // remove markers that don't match the search query\n                    for (var bid in $scope.sites) {\n                        if (!newSiteMap[bid]) {\n                            $scope.siteLayer.removeLayer($scope.sites[bid].marker);\n                        }\n                    }\n\n                    for (i in $scope.buildings) {\n                        building = $scope.buildings[i];\n                        site = $scope.getSite(building);\n                        if(site) {\n                            setupDynamicBuildingSiteInterop(building, site);\n                        } // else, the building was not geocoded\n                    }\n\n                    setupStaticBuildingSiteInterop();\n                };\n\n                config.loadAPI({\n                    'openPopup': openPopup,\n                    'closePopup': closePopup,\n                    'togglePopup': togglePopup,\n                    'getBuilding': $scope.getBuilding, // TODO: remove\n                    'getSite': $scope.getSite,\n                    'sitePopupIsOpen': $scope.sitePopupIsOpen,\n                    'updateBuilding': _buildingChange,\n                    'updateBuildings': $scope.updateBuildings,\n                    'updateBuildingHighlight': $scope.updateBuildingHighlight,\n                    'updateAllBuildingsHighlight': $scope.updateAllBuildingsHighlight,\n                    'withDynamicBuilding': $scope.withDynamicBuilding,\n                    'centerOnMap': function(site, callback) {\n                        $scope.siteLayer.zoomToShowLayer(site.marker, callback);\n                    },\n                    'pruneMarkers': $scope.pruneMarkers\n                });\n\n            }\n        ]);\n})(angular);\n","/**\n * Building Map Directive\n *\n * Creates a Leaflet map that displays clustered dynamically updated buildings\n * with popups and all kinds of bells and whistles.\n *\n * A lot of the complexity of this code comes from the fact that we have to keep\n * two distinct lists up to date and interoperating - the building list, which\n * show up in the building table, and the \"mapBuilding\", or \"site\" list, which\n * represents light-weight building objects that are displayed on the map.\n * In general there are many more sites than buildings\n * (up to 10,000 sites, up to 100 buildings), but when showing more information\n * on a site (e.g. in a popup), the entire building object be present. If it\n * already exists in the table, that object is used, but if not it is loaded\n * asynchronously and the necessary objects and events are created and bound\n * at that point\n *\n * Some key functions to understanding this code: (2014-11-26 MDD)\n * loadAPI - a callback that lets the parent receive a handy API into map\n *      functionality\n * withDynamicBuilding - accepts a callback that guarantees the existence of a\n *      building, crucial for working with the many times a building must be\n *      loaded asynchronously. It's safe to call this many times, as buildings\n *      are cached as they're loaded.\n * updateBuildings - winds up being called every time a new search query is\n *      fired. Existing sites are not updated, their markers and popups are\n *      preserved\n *\n */\n\n(function(angular) {\n\n    /**\n     * Get class name based on relative map position\n     * @param  {L.Map} map\n     * @param  {L.Point} position The marker position\n     * @return {String}          The popup class name\n     */\n    var popupClassName = function(map, position) {\n        var dim = map.getSize();\n        var xClass, yClass;\n\n        if (position.x <= dim.x/3) {\n            xClass = 'left';\n        } else if (position.x <= dim.x*2/3) {\n            xClass = 'center';\n        } else {\n            xClass = 'right';\n        }\n\n        if (position.y <= dim.y/2) {\n            yClass = 'top';\n        } else {\n            yClass = 'bottom';\n        }\n        return xClass + ' ' + yClass;\n    };\n\n    /**\n     * Set popup class based on its position on the map\n     * @param {L.Map} map\n     * @param {L.Popup} popup\n     */\n    var setPopupClass = function(map, popup) {\n\n        var position = map.latLngToContainerPoint(popup.marker.getLatLng());\n        $(popup._container).removeClass('top bottom left right center').addClass(\n            popupClassName(map, position) + ' has_value'\n        );\n    };\n\n    angular.module('BE.frontend.buildingMap')\n        .directive('buildingMap', [\n            function() {\n                return {\n                    restrict: 'A',\n                    scope: {\n                        buildings: '=buildings',\n                        getSites: '&buildingSites',\n                        getConfig: '&config',\n                        tileset: '@',\n                        initialCenter: '&',\n                        initialZoom: '&',\n                    },\n                    controller: 'BuildingMapController',\n                    link: function($scope, element, attrs) {\n\n                        var config = $scope.config;\n\n                        var defaultMarkerIcon = null;\n                        var map = $scope.createMap(element[0]);\n\n                        var _activeSite = null;\n\n                        /**\n                         * Determine if this marker is independent, or absorbed\n                         * into a cluster\n                         * @param  {[type]}  marker\n                         * @return {Boolean}\n                         */\n                        var isIndependent = function(marker) {\n                            var parent = $scope.siteLayer.getVisibleParent(marker);\n                            return parent === null || parent === marker;\n                        };\n\n                        /**\n                         * Fit map bounds to markers displayed\n                         * @param  {L.Map} map\n                         * @param  {L.LayerGroup} layer\n                         */\n                        var setMapBounds = _.debounce( function(map, layer) {\n                            if(layer.getLayers().length > 0) {\n                                var bounds = layer.getBounds();\n                                map.fitBounds(bounds, {padding: [20, 20]});\n                            } else {\n                                map.setView([40, -95], 4);\n                            }\n                        }, 300);\n\n                        $scope.map = map;\n\n                        $scope.siteLayer = new L.MarkerClusterGroup({\n                            spiderfyDistanceMultiplier: 2,\n                            maxClusterRadius: function(zoom) {\n                                if (zoom <= 15) return 60;\n                                else if (zoom <= 16) return 20;\n                                else return 2;\n                            },\n                        });\n\n                        map.addLayer($scope.siteLayer);\n\n                        $scope.controlLayer = L.control.layers([], {\n                            'Buildings': $scope.siteLayer,\n                        }).addTo(map);\n\n\n                        /************************\n                        ** MAP EVENT LISTENERS **\n                        ************************/\n\n                        map.on('load', function(e) {\n                            setMapBounds(map, $scope.siteLayer);\n\n                            // debounce, and throw away the first invocation\n                            map.on('zoomend dragend resize', _.debounce(function(e) {\n                                // NOTE: DON'T use moveend,\n                                // because that fires when the map loads!\n                                config.onViewportChange(map);\n                            }, 100));\n                            if (config.initialize) {\n                                config.initialize(map, $scope.controlLayer);\n                            }\n                        });\n\n                        map.on('popupopen', function(e) {\n                            setPopupClass(map, e.popup);\n                            $(e.popup._container).find('.close_it').one('click', function(e) {\n                                map.closePopup();\n                            });\n                            e.popup.site.popupIsOpen = true;\n                        });\n\n                        map.on('popupclose', function(e) {\n                            e.popup.site.popupIsOpen = false;\n                        });\n\n                        if($scope.initialCenter() && $scope.initialZoom()) {\n                            map.setView($scope.initialCenter(), $scope.initialZoom());\n                        } else {\n                            setMapBounds(map, $scope.siteLayer);\n                        }\n\n                        var _markerHighlighted = function(marker) {\n                            return marker.site._highlighted;\n                        };\n\n                        var _leaflet_id = function(cluster) {\n                            return cluster._leaflet_id;\n                        };\n\n                        var updateClusterHighlight = function() {\n                            var zoom = $scope.map.getZoom();\n                            var clusters = [];\n                            var markers = $scope.siteLayer.getLayers();\n\n                            for (var m in markers) {\n                                var marker = markers[m];\n                                var site = marker.site;\n                                if (site._highlighted) {\n                                    clusters.push(marker.__parent);\n                                }\n                            }\n                            clusters = _.uniq(clusters, _leaflet_id);\n                            for (var c in clusters) {\n                                var cluster = clusters[c];\n                                while (cluster.__parent && cluster._zoom >= zoom) {\n                                    if (cluster._icon) {\n                                        $(cluster._icon).addClass('marker-cluster-highlighted');\n                                    }\n                                    cluster = cluster.__parent;\n                                }\n                            }\n\n                        };\n\n                        $scope.siteLayer.on('animationend', function(e) {\n                            updateClusterHighlight();\n                            $scope.updateAllBuildingsHighlight();\n                            //\n                            // if(!_activeSite || !isIndependent(_activeSite.marker)) {\n                            //     map.closePopup();\n                            // }\n                        });\n\n                    },\n                };\n        }]);\n})(angular);\n"],"sourceRoot":"/source/"}